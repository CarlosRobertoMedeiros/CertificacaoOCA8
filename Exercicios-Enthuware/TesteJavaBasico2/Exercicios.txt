Basic Java

1-

Which of the given options should be inserted at line 1 so that the following code can compile without any errors?

package objective1;
// 1
public class StaticImports{
    
    public StaticImports(){
    out.println(MAX_VALUE);
    }
    
}

1 - import static java.lang.Integer.*;  --CERTO
2 - static import java.lang.System.out;
3 - static import Integer.MAX_VALUE;
4 - import static java.lang.System.*;   --CERTO
	/*The code uses out.println instead of System.out.println. out is a static field in java.lang.System class. 
	That is why you need to import the static fields of java.lang.System.

5 - static import java.lang.System.*;

General:
The order of keywords for a static import must be "import static ... ".
  You can either import all the static members using import static java.lang.Integer.* or one specific member 
using import static java.lang.Integer.MAX_VALUE;
  You must specify the full package name of the class that you are importing (just like the regular import statement). 
So, import static Integer.*; is wrong.


********************************************************************************************************************

2 -

Given the following class, which of these are valid ways of referring to the class from outside of the package com.enthu?

package com.enthu;
public class Base{
   // lot of code...
}

1 - Base
	//Only if you import the whole package containing the class or import the class first.
2 - By importing the package com.* and referring to the class as enthu.Base
	//package 'com' does not contain Base.
3 - importing com.* is illegal.
	//It is perfectly legal but will not help here
4 - By importing com.enthu.* and referring to the class as Base. --CERTO
5 - By referring to the class as com.enthu.Base.		 --CERTO

General

	A class or interface can be referred to by using its fully qualified name or its simple name.
	Using the fully qualified name will always work, but to use the simple name either the class must be in the same 
package or it has to be imported.
	By importing com.enthu.* all the classes from the package will be imported and can be referred to using 
simple names.
	Importing com.* will not import the subpackage enthu. It will only import the classes in package com.



********************************************************************************************************************
3 - 

Which of the given options can be successfully inserted at line 1....

//line 1
   public class A{
   }

1 - import java.lang.*; --CERTO
	//Although this package is automatically imported, it is not an error to import it explicitly.
2 - package p.util; --CERTO
	//It is a perfectly valid package statement.
3 - public class MyClass{ }  --ERRADO não se pode no mesmo arquivo ter duas classes públicas
4 - abstract class MyClass{ } --CERTO
	//You can have more than one classes in a file but at most one of them can be public.
	
General
To make a class abstract, you only need to mark it abstract as shown in Option 4. You don't necessarily need to 
put an abstract method in a class

********************************************************************************************************************
4 -  Identify correct option(s)

1 - Multiple inheritance of state includes ability to inherit instance methods from multiple classes.
	//  Methods do not have state. Ability to inherit instance methods from multiple classes is called multiple inheritance 
	//of implementation. Default methods introduce one form of multiple inheritance of implementation. A class can implement 
	//more than one interface, which can contain default methods that have the same name. However, such a class cannot be compiled. 
	//In this case, the implementing class is required to provide its own implementation of the common method to avoid ambiguity.
2 - Multiple inheritance of state includes ability to inherit instance fields from multiple classes. --CERTO
3 - Multiple inheritance of type includes ability to inherit instance fields as well as instance methods from multiple classes.
4 - Multiple inheritance of type includes ability to implement multiple interfaces and ability to inherit static or instance fields from interfaces and/or classes.
5 - Multiple inheritance of type includes ability to implement multiple interfaces and/or ability to extend from multiple clases --CERTO


General

Interfaces, classes, and enums are all "types". Java allows a class to implement multiple interfaces. In this way, Java supports 
multiple inheritance of types.
"State", on the other hand, is represented by instance fields. Only a class can have instance fields and therefore, only a class 
can have a state. (Fields defined in an interface are always implicitly static, even if you don't specify the keyword static explicitly. 
Therefore, an interface does not have any state.) Since a class is allowed to extend only from one class at the most, it can 
inherit only one state. Thus, Java does not support multiple inheritance of state.

This is an important concept and is explained in more detail here: https://docs.oracle.com/javase/tutorial/java/IandI/multipleinheritance.html


********************************************************************************************************************
5 - 

Which of the following lines can be inserted at line 1 to make the program run?

//line 1
public class TestClass{
  public static void main(String[] args){
     PrintWriter pw = new PrintWriter(System.out);
     OutputStreamWriter osw  =  new OutputStreamWriter( System.out );
     pw.print("hello");
  }
}

Assume that PrintWriter and OutputStreamWriter are valid classes in java.io package

1 - import java.lang.*;
	//Although you can import java.lang package explicitly, it is not required because this package is always imported by the compiler
2 - import java.io.*; --CERTO
	//This will make all the classes of java.io package available
3 - import java.io.OutputStreamWriter;
	//This will only make OutputStreamWriter available. PrintWriter will still be unavailable.
4 - include java.io.*;
	//nclude is not valid keyword in Jav
5 - include java.lang.System;

********************************************************************************************************************

6 - 

You have written some Java code in MyFirstClass.java file. Which of the following commands will you use to compile and run it.
(Assume that the code has no package declaration.)

1 - javac MyFirstClass.java
    javar MyFirstClass
2 - javap MyFirstClass.java
    javar MyFirstClass.java
3 - java MyFirstClass.java
    java MyFirstClass.class
4 - javac MyFirstClass.java
    javar MyFirstClass.java
5 - javac MyFirstClass.java --CERTO
    java MyFirstClass

General

  Remember that java code must be written in a file with .java extension. If you have a public type (class, interface, or enum) in 
the code, the name of the file must be same as the name of that public type.
  Compilation and execution of a Java program is two step process. You first need to compile a java file using a Java compiler. 
Oracle's JDK comes with a compiler. It is contained in the executable file named javac. 
You will find it in <jdk installation folder>/bin.

  javac compiles the source code and generates bytecode in a new file with the same name as the source file but with extension .class. 
By default, the class file in generated in the same folder but javac is capable of placing it in a different folder if you use the -d flag.
[This is just FYI and not required for the exam. -d is a very important and useful flag and we recommend that you read about it even if 
it is not required for the exam.]

In second step, the Java virtual machine (JVM), aka Java interpreter is invoked to execute the .class file. Oracle's JVM is contained 
in the executable file named java. It is also present in the same bin folder of JDK installation. It takes the fully qualified name
 (i.e. name including package) of the class file without extension as a argument.


********************************************************************************************************************

7 - 

Consider the following code:
 import java.util.ArrayList;

 public class Student{
    
    ArrayList<Integer> scores;
    private double average;
    
    public ArrayList<Integer> getScores(){ return scores; }
    
    public double getAverage(){ return average; }
    
    private void computeAverage(){
        //valid code to compute average
        average =//update average value
    }

    public Student(){
        computeAverage();
    }

    //other code irrelavant to this question not shown

}
What can be done to improve the encapsulation of this class?

1 - Make the class private.
2 - Make the scores instance field private. --CERTO
	//An important aspect of encapsulation is that other classes should not be able to modify the state fields of a class directly. 
	//Therefore, the data members should be private (or protected if you want to allow subclasses to inherit the field) and if the 
	//class wants to allow access to these fields, it should provide appropriate setters and getters with public access.
3 - Make getScores() protected.
4 - Make computeAverage() public.
5 -Change getScores to return a copy of the scores list: --CERTO
     public ArrayList<Integer> getScores(){
       return new ArrayList(scores);
     }
	//If you return the same scores list, the caller would be able to add or remove elements from it, thereby rendering the average incorrect.
	//This can be prevented by returning a copy of the list.


********************************************************************************************************************

8 - 

Consider the following two classes defined in two .java files.

//in file /root/com/foo/X.java
package com.foo;
public class X{
  public static int LOGICID = 10;
  public void apply(int i){
    System.out.println("applied");
  }
}

//in file /root/com/bar/Y.java
package com.bar;
//1  <== INSERT STATEMENT(s) HERE
public class Y{
    public static void main(String[] args){
       System.out.println(X.LOGICID);
    }
}
What should be inserted at //1 so that Y.java can compile without any error?

1 - import static X;
2 - import static com.foo.*;  
	// Bad syntax. Package import does not use static keyword.
3 - import static com.foo.X.*;
	//This static import, although syntactically correct, will not help here because Y is accessing class X in X.LOGICID
4 - import com.foo.*;            --CERTO
	//   This is required because Y is accessing class X. static import of LOGICID is NOT required because Y is accessing LOGICID 
	// through X ( X.LOGICID). Had it been just System.out.println(LOGICID), only one import statement: import static com.foo.X.*; 
	// would have worked.
5 - import com.foo.X.LOGICID;
	//Bad Syntax. Syntax for importing static fields is:  import static <package>.<classname>.*; or import static <package>.<classname>.<fieldname>;

********************************************************************************************************************

9 - 

What will the following code print when run?

public class TestClass{
  public static long main(String[] args){
     System.out.println("Hello");
     return 10L;
  }
}

1 - Hello
2 - It will not print anything.
3 - It will not compile                
4 - It will throw an Error at runtime. --CERTO
5 - None of the above.

General

  When the program is run, the JVM looks for a method named main() which takes an array of Strings as input and returns nothing 
(i.e. the return type is void).
  But in this case, it doesn't find such a method ( the given main() method is returning long!) so it gives out the following message:
  Error: Main method must return a value of type void in class TestClass, please
define the main method as:
   public static void main(String[] args)


********************************************************************************************************************

10 - 

What will be result of attempting to compile this class?

import java.util.*;
package test;
public class TestClass{
    public OtherClass oc = new OtherClass();
}
class OtherClass{
    int value;
}

1- The class will fail to compile, since the class OtherClass is used before it is defined.
2- There is no problem with the code.
3- The class will fail to compile, since the class OtherClass must be defined in a file called OtherClass.java
	//This is not needed because OtherClass is not public. The class & file name must match only if the class is public.
4- The class will fail to compile . --CERTO
5- None of the above.

General

The order is:
package statement.
import statements
class/ interface definitions.
Important point to note here is YOU MUST READ THE QUESTIONS VERY CAREFULLY

********************************************************************************************************************

11 - 

Following options show the complete code listings of a file. Which of these will compile?

1 - //In file A.java
import java.io.*;
package x;
public class A{
}
  //The package statement, if exists, must be the first statement in a java code file. If you move it up before the import, 
  // this code will compile.

2 - //In file B.java
import java.io.*;
class A{
  public static void main() throws IOException{ } --CERTO
}
  //There is nothing wrong with this code.
  //1. You can have a non-public class in a file with a different name.
  //2. You can have a main method that doesn't take String[] as an argument. It will not make the class executable from the command line though

3 - //In file A.java
public class A{        
   int a;
   public void m1(){
     private int b = 0; //dentro de um método não tem modificador de acesso
     a = b;
   }
}
  //Access modifiers (public/private/protected) are valid only inside the scope of a class, not of a method.

4 - //In file A.java
public class A{                               --CERTO
  public static void main(String[] args){
    System.out.println(new A().main);
  }   
  int main;
}
  //There is nothing wrong with this code. You can have a method and a field with the same name in a class

5 - Only one of the above options is correct. 

********************************************************************************************************************

12 - 

Given the following contents of two java source files:

package util.log4j;
public class Logger  {
  public void log(String msg){
      System.out.println(msg);
  }
}

and

package util;
public class TestClass {
    public static void main(String[] args) throws Exception {
        Logger logger = new Logger();
        logger.log("hello");
    }
}

What changes, when made independently, will enable the code to compile and run?


1- Replace Logger logger = new Logger(); with: log4j.Logger logger = new log4j.Logger();
	//  If you are not importing a class or the package of the class, you need to use the class's fully qualified name while using it. 
	//Here, you need to use util.log4j.Logger instead of just log4j.Logger: util.log4j.Logger logger = new util.log4j.Logger();
2 - Replace package util.log4j; with package util; --CERTO
	//  This will put both the classes in the same package and TestClass can then directly use Logger 
	//class without importing anything.
3 - Replace Logger logger = new Logger(); with: util.log4j.Logger logger = new util.log4j.Logger(); --CERTO
	//   Using a fully qualified class name always works irrespective of whether you import the package or not.  
	//In this case, all classes of package util are available in TestClass without any import statement but Logger is in util.log4j. 
        //Therefore, the use of fully qualified class name for Logger, which is util.log4j.Logger, makes it work.
4 - Remove package util.log4j; from Logger.
	// Remember that you can never access a class that is defined in the default package (i.e. the package with no name) from 
        // a class in any other package. So if you remove the package statement from Logger, 
	// you can't access it from util package, which is where TestClass is.
5-  Add import log4j; to TestClass.
	// This will not help because Logger is in util.log4j package and not in log4j package
	
********************************************************************************************************************

13 - 

Consider the following two classes defined in two java source files.

//in file /root/com/foo/X.java
package com.foo;
public class X{
  public static int LOGICID = 10;
  public void apply(int i){
    System.out.println("applied");
  }
}

//in file /root/com/bar/Y.java
package com.bar;
//1 <== INSERT STATEMENT(s) HERE
public class Y{
    public static void main(String[] args){
       X x = new X();
       x.apply(LOGICID);
    }
}
What should be inserted at //1 so that Y.java can compile without any error?


1 - import static X;
2 - import static com.foo.*;  
	//Bad syntax. com.foo is a package and you cannot import a package statically. You can only import static members of a class statically.  
3 - import static com.foo.X.*;  -- CERTO
	//This static import is required because of Y is accessing LOGICID directly without its class name ( i.e. X.LOGICID).
4 - import com.foo.*;           -- CERTO
	//This is required because Y also accesses the class X : X x = new X(); If Y had only one statement, 
	// System.out.println(LOGICID); import static com.foo.X.* would suffice
5 - import com.foo.X.LOGICID;
	Syntax for importing static fields is:  import static <package>.<classname>.*; or import static <package>.<classname>.<fieldname>;
	

********************************************************************************************************************

14 - 

Which of these statements are true?

1 - A static method can call other non-static methods in the same class by using the 'this' keyword.
	//'this' reference is not available within a static method
2 - A class may contain both static and non-static variables and both static and non-static methods. --CERTO
3 - Each object of a class has its own copy of each non-static member variable.			     --CERTO
4 - Instance methods may access local variables of static methods.
	//local variables can only be accessed in the method they are defined. So you cannot access them anywhere outside that method.
5 - All methods in a class are implicitly passed a 'this' parameter when called.
	//All non-static/instance methods in a class are implicitly passed a 'this' parameter when called


General

  'this' is assigned a reference to the current object automatically by the JVM. Thus, within an instance method foo, calling this.foo();
is same as calling foo();
  Since there is no current object available for a static method, 'this' reference is not available in static methods and therefore it 
can only be used within instance methods. For the same reason, static methods cannot access non static fields or methods of that class
directly i.e. without a reference to an instance of that class.
  Note : you can't reassign 'this' like this:
  this = new Object(); 

********************************************************************************************************************

15 - 

What will the following code print when compiled and run?

public class Paper {
    public String title;
    public int id;
    
    public Paper(String title, int id){
        this.title = title;
        this.id = id;
    }
    
    public static void main(String[] args) {
        Paper[] papers = {
            new Paper("T1", 1),
            new Paper("T2", 2),
            new Paper("T3", 3)
        };
        
        System.out.println(papers);
        System.out.println(papers[1]);
        System.out.println(papers[1].id);
    }
}


1 - papers
Paper
2

2 - papers
T2,2
2

3 - [LPaper;@<hashcode>
Paper
2

4 - [LPaper;@<hashcode> -- CERTO
Paper@<hashcode>
2

General

You may find a few simple questions in the exam that expect you to know what is printed when you pass an array to System.out.print/println. 
All you need to know is that when the class (or the superclass) of an object does not override the toString method, Object class's toString
 is used, which prints the name of the class + @ sign + hash code of the object.

Now, in case of an array, the name of the class is a little complicated. The details 
(given here: http://docs.oracle.com/javase/8/docs/api/java/lang/Class.html#getName-- ) are: The internal form of the name consists of the 
name of the element type preceded by one or more '[' characters representing the depth of the array nesting. The encoding of element type 
names is as follows:

Element Type   Encoding
boolean   Z
byte      B
char      C
class or interface   Lclassname;  <-- Observe the character L here
double    D
float     F
int       I
long      J
short     S

For example, the name of one dimensional byte array is [B. Therefore, if you pass it to print/println method, [B@<hashcode> will be printed.
The name of two dimensional byte array is [[B. Therefore, if you pass it to print/println method, [[B@<hashcode> will be printed.

Thus, in this question, the first println statement will print [LPaper;@<hashcode> and the second println will print Paper@<hashcode>, 
both followed by a new line, of course.

********************************************************************************************************************

16 - 

Given the following code:
interface Movable{
   int offset = 100;
   public void move(int dx);
}
interface Growable{
  public void grow(int dy);
}

class Animal implements Movable, Growable{
   public void move(int dx){ }
   public void grow(int dy){ }
}


1 - Animal class illustrates Java's support for multiple inheritance of type. --CERTO
2 - Animal class illustrates Java's support for multiple inheritance of state.
3 - Animal class illustrates Java's support for multiple inheritance of type as well as state.
4 - Animal class illustrates Java's support for multiple implementation inheritance.
	// Java 8 allows an interface to contain implementations (in the form of default methods and as static methods). However, Java 8 still does not allow a class to inherit multiple implementations of the same method from two different unrelated interfaces. For example, 
	// the following will not compile:
	/*
	interface Movable{
	   public default void move(int dx) { System.out.println("in m");}
	}
	interface Growable{
	   public default void move(int dx) { System.out.println("in g");}
	}

	class Animal implements Movable, Growable{
	}

	Compiler will complain that class Animal inherits unrelated defaults for move(int) from types Movable and Growable. To make it compile, 
	you must provide an implementation of the move method explicitly in Animal class
	*/

General 

Interfaces, classes, and enums are all "types". Java allows a class to implement multiple interfaces. In this way, Java supports multiple 
inheritance of types.
"State", on the other hand, is represented by instance fields. Only a class can have instance fields and therefore, only a class can have 
a state. (Fields defined in an interface are always implicitly static, even if you don't specify the keyword static explicitly. 
Therefore, an interface does not have any state.) Since a class is allowed to extend only from one class at the most, it can inherit only one 
state. Thus, Java does not support multiple inheritance of state.

This is an important concept and is explained in more detail here: https://docs.oracle.com/javase/tutorial/java/IandI/multipleinheritance.html

********************************************************************************************************************

17 - 

Which of the following are correct about "encapsulation"?

1 - Encapsulation is same as polymorphism.
2 - It helps make sure that clients have no accidental dependence on the choice of representation --CERTO
3 - It helps avoiding name clashes as internal variables are not visible outside.                 --CERTO
4 - Encapsulation makes sure that messages are sent to the right object at run time.
	//This is dynamic binding, an outcome of polymorphism
5 - Encapsulation helps you inherit the properties of another class.


General

Encapsulation is the technique used to package the information in such a way as to hide what should be hidden, and make visible what is 
intended to be visible. In simple terms, encapsulation generally means making the data variables private and providing public accessors.


********************************************************************************************************************

18 - 

What will the following code print when compiled and run?


public class ATest {
    
    
    String global = "111";
    
    public int parse(String arg){
        int value = 0;
        try{
            String global = arg;            
            value = Integer.parseInt(global);
        }
        catch(Exception e){
            System.out.println(e.getClass());
        }
        System.out.print(global+" "+value+" ");
        return value;
    }
       public static void main(String[] args) {
          ATest ct = new ATest();
           System.out.print(ct.parse("333"));
       }

}


1 - 111 333 333 -- CERTO
2 - 333 333 333
3 - java.lang.NumberFormatException
4 - java.lang.Exception
5 - Compilation fails.

General

Observe that a new local variable named global is defined within a try block. It is accessible only within the try block. It also shadows 
the instance field of the same name global within the try block. It is this variable that is used in parseInt. Therefore, 
value is set to 333.
However, when you print global in parse method, the global defined in the try block is out of scope and the instance field named 
global is used. Therefore, it prints 111.

There is no exception because 333 can be parsed into an int. If you pass a string that cannot be parsed into an int to the parseInt method, it will throw a java.lang.NumberFormatException.

********************************************************************************************************************

19 - Which of the following are benefits of polymorphism?

1 - It makes the code more reusable. --CERTO
2 - It makes the code more efficient.
	// This option is a bit ambiguous because it is not clear which efficiency is it talking about - execution, memory, or maintenance. 
	// Our guess is that it is referring to execution efficiency. It is not true because polymorphism causes a very slight degradation 
	// due to dynamic binding at run time.	
3 - It protects the code by preventing extension.
	//Just the reverse is true. Extension is how polymorphism is achieved
4 - It makes the code more dynamic. --CERTO
	//  Polymophism allows the actual decision of which method is to be invoked to be taken at runtime based on the actual class of object. 
	//This is dynamic binding and makes the code more dynamic

********************************************************************************************************************

20 - 

What will be the output of the following program when it is compiled and run with the command line:

java TestClass 1 2 3

public class TestClass {

    public static void main(String[] args) {
        System.out.println("Values : "+args[0]+args[1]);
    }
}

1 - Values : java TestClass
2 - Values : TestClass 1
3 - Values : 12 -- CERTO
4 - Values : 23
5 - Values : 3

General

  In Java, command line arguments are passed into the program using the String[] parameter to the main method. The String array contains 
actual parameters and does not include java and the name of the class.
  Therefore, in this case, args will point to an array of Strings with 3 elements - "1", "2", and "3". The program prints out only args[0] 
and args[1], which are 1 and 2

********************************************************************************************************************

21 - 

Consider the following class:

public class ArgsPrinter{
   public static void main(String args){
      for(int i=0; i<3; i++){
         System.out.print(args+" ");
      }
   }
}

What will be printed when the above class is run using the following command line:
java ArgsPrinter 1 2 3 4

1 - 1 2 3
2 - ArgsPrinter 1 2
3 - java ArgsPrinter 1 2
4 - 1 1 1
5 - None of the above. --CERTO 

General 

  To run a class from the command line, you need a main(String[] ) method that takes an array of Strings array not just a String.
  Therefore, an exception will be thrown at runtime saying no main(String[] ) method found. Note that String[] and String... 
are equivalent and so  parameter type of String... is also valid for main method. When you use String... 
the compiler allows you to pass any number of String arguments to that method but internally, compiler converts String... 
to String[]. 
  It also wraps the arguments into a String[] and invokes the String[] method. The JVM has no idea about String.... It sees 
  only String[].

********************************************************************************************************************

22 - 

Which of the following statement(s) is/are correct?

1 - Java supports multiple type inheritance as well as multiple state inheritance.
2 - Java supports multiple type inheritance but not multiple state inheritance. -- CERTO
3 - Java does not support multiple type inheritance but supports multiple state inheritance.
4 - Java does not support multiple type or state inheritance.

General
Java allows a class to implement multiple interfaces. An interface is a "type" and does not contain any state. 
This implies that Java supports multiple type inheritance.
A class contains state and extending a class means inheriting the state. Since Java does not allow a class to extend f
rom multiple classes, it means that Java does not support multiple state inheritance.

This is an important concept and is explained in more detail here: 
https://docs.oracle.com/javase/tutorial/java/IandI/multipleinheritance.htm

********************************************************************************************************************

23 - 

What is meant by "encapsulation" ?

1 - There is no way to access member variable.
2-  There are no member variables.
3-  Member fields are declared private and public accessor/mutator methods are provided to access and change their values if needed.
4 - Data fields are declared public and accessor methods are provided to access and change their values.

General

  Encapsulation is one of the 4 fundamentals of OOP (Object Oriented Programming).
  Encapsulation means that the internal representation of an object is generally hidden from view outside of the object's 
definition. Typically, only the object's own methods can directly inspect or manipulate its fields. Some languages like 
Smalltalk and Ruby only allow access via object methods, but most others (e.g. C++ or Java) offer the programmer a degree 
of control over what is hidden, typically via keywords like public and private.
  Hiding the internals of the object protects its integrity by preventing users from setting the internal data of the component 
  into an invalid or inconsistent state. A benefit of encapsulation is that it can reduce system complexity, and thus increases 
  robustness, by allowing the developer to limit the interdependencies between software components.

********************************************************************************************************************

24 - 

Consider the classes shown below:

class A{
   public A() { }
   public A(int i) {   System.out.println(i );    }
}
class B{
   static A s1 = new A(1);
   A a = new A(2);
   public static void main(String[] args){
      B b = new B();
      A a = new A(3);
   }
   static A s2 = new A(4);
}
Which is the correct sequence of the digits that will be printed when B is run?

1 - 1 ,2 ,3 4.
2 - 1 ,4, 2 ,3 --CERTO
3 - 3, 1, 2, 4
4 - 2, 1, 4, 3
5 - 2, 3, 1, 4

General

1. All static constants, variables, and blocks. Among themselves the order is the order in which they appear in the code. This 
step is actually a part of "class initialization" rather than "instance initialization". Class initialization happens only if 
the class is being used for the first time while being instantiated. For example, if you have invoked a static method of a 
class or accessed a static field of that class earlier in the code, you have already used the class and the JVM would have 
performed initialization of this class at that time. Thus, there wouldn't be any need to initialize the class if you 
instantiate an object of this class now.

Further, if the class has a superclass, then the JVM performs this step for the superclass first (if the superclass hasn't 
been initialized already) and only after the superclass is initialized and static blocks are executed, does the JVM proceed 
with this class. This process is followed recursively up to the java.lang.Object class.

2. All non static constants, variables, and blocks. Among themselves the order is the order in which they appear in the code.

3. Constructor.

Just like the class initialization, instance initialization also happens for the superclass first. That is, if the class has a 
superclass, then the JVM takes steps 2 and 3 given above for the superclass first and only after the superclass's instance 
members are initialized, does the JVM proceed with this class. This process is also followed recursively up to the 
java.lang.Object class.

********************************************************************************************************************

25 - 

Given the following program, which statement is true?

class SomeClass{
   public static void main( String args[ ] ){
      if (args.length == 0 ){
         System.out.println("no arguments") ;
      }
      else{
         System.out.println( args.length + " arguments") ;
      }
   }
}


1 - The program will fail to compile.
2 - The program will throw a NullPointerException when run with zero arguments.
3 - The program will print no arguments when called with zero arguments and 1 arguments  when called with one argument.
	//The word java and class name are not a part of the argument list.
4 - The program will print no arguments and 2 arguments when called with zero and one arguments.
5 - The program will print no arguments and 3 arguments when called with zero and one arguments.
	//When the program is called with no arguments, the args array will be of length zero.
	
General

  When the program is called with no arguments, the args array will be of length zero. Unlike in C/C++, args[0] is not the 
name of the program or class. This is because the name of the class is always the same as defined in the java file. So 
there is no need for passing its name as an argument to main method.

********************************************************************************************************************

26 - 

Consider the following class written by a novice programmer.

class Elliptical{
    public int radiusA, radiusB;
    public int sum = 100;

    public void setRadius(int r){
        if(r>99) throw new IllegalArgumentException();
        radiusA = r;
        radiusB = sum - radiusA;
        
    }
}
After some time, the requirements changed and the programmer now wants to make sure that radiusB is always (200 - radiusA) 
instead of (100 - radiusA) without breaking existing code that other people have written. Which of the following will 
accomplish his goal?

1 - Make sum = 200;
2 - Make sum = 200 and make it private.
3 - Make sum = 200 and make all fields (radiusA, radiusB, and sum) private.
	//This should have been done when the class was first written.
4 - Write another method setRadius2(int r) and set radiusB accordingly in this method.
5 - His goal cannot be accomplished. --CERTO
		//This class will not compile.
		//There is no problem with the code. Remember, IllegalArgumentException extends from RuntimeException 
		// and is a super class of NumberFormatException

General
	setRadius method makes sure that radiusB is set to sum - radiusA. So changing sum to 200 should do it. However, note that 
radiusA, radiusB, and sum are public which means that any other class can access these fields directly without going 
through the setRadius method. So there is no way to make sure that the value of radiusB is correctly set at all times. If you 
make them private now, other classes that are accessing the fields directly will break.
	The class should have been coded with proper encapsulation of the fields in the first place.

********************************************************************************************************************

27 - 

You are writing a class named Bandwidth for an internet service provider that keeps track of number of bytes consumed by a user. The following code illustrates the expected usage of this class -

class User{
    Bandwidth bw = new Bandwidth();
    
    public void consume(int bytesUsed){
        bw.addUsage(bytesUsed);
    }
   ... other irrelevant code    
}

class Bandwidth{
    private int totalUsage;
    private double totalBill;
    private double costPerByte;
    
   
    //add your code here

    ...other irrelevant code
}

Your goal is to implement a method addUsage (and other methods, if required) in Bandwidth class such that all the bandwidth used by a User is reflected by the totalUsage field and totalBill is always equal to totalUsage*costPerByte. Further, that a User should not be able to tamper with the totalBill value and is also not able to reduce it.

Which of the following implementation(s) accomplishes the above?

1 - public void addUsage(int bytesUsed){ --CERTO
    if(bytesUsed>0){
       totalUsage = totalUsage + bytesUsed;
       totalBill = totalBill + bytesUsed*costPerByte;
    }
}

2 - protected void addUsage(int bytesUsed){
       totalUsage += bytesUsed;
       totalBill = totalBill + bytesUsed*costPerByte;
}
	//There is no validity check for bytesUsed argument. User will be able to tamper will the bill by suppling a 
	//negative number for bytesUsed.

3 - private void addUsage(int bytesUsed){
    if(bytesUsed>0){
       totalUsage = totalUsage + bytesUsed;
       totalBill = totalUsage*costPerByte;
    }
}
	//If this method is made private, User class will not be able to access it.

4 - public void addUsage(int bytesUsed){
    if(bytesUsed>0){
       totalUsage = totalUsage + bytesUsed;
    }
}

5 - public void updateTotalBill(){
    totalBill = totalUsage*costPerByte;
}
	//This is not a good approach because once the User class calls addUsage() method, totalBill field will not reflect the 
	//correct amount unless User also calls updateTotalBill, which means Bandwidth class is now dependent on some other 
	// class to keep its internal state consistent with the business logic.
	
********************************************************************************************************************

28 - 

Given the following set of member declarations, which of the following is true?

 int a;    //  (1)
 static int a;    //  (2)
 int f( )   { return a; }    //  (3)
 static int f( ) { return a; }    //  (4)
 
1 - Declarations (1) and (3) cannot occur in the same class definition.
2 - Declarations (2) and (4) cannot occur in the same class definition.
	//A static method can refer to a static field.
3 - Declarations (1) and (4) cannot occur in the same class definition. --CERTO
	//because method f() is static and a is not.
4 - Declarations (2) and (3) cannot occur in the same class definition.
5 - Declarations (1) and (2) cannot occur in the same class definition.	--CERTO
	//variable names must be different. 

General

Local variables can have same name as member variables. The local variables will simply shadow the member variables with the 
same names.
Declaration (4) defines a static method that tries to access a variable named 'a' which is not locally declared.
Since the method is static, this access will only be valid if variable 'a' is declared static within the class. Therefore 
declarations (1) and (4) cannot occur in the same definition

********************************************************************************************************************

29 - 

The options below contain the complete contents of a file.
Which of these options can be run with the following command line once compiled?
java main


//in file main.java
1 - class main {
   public void main(String[] args) {
       System.out.println("hello");
   }
}
	//The main method should be static.

//in file main.java
2 -  public static void main(String[] args) {
       System.out.println("hello");
   }
	//You cannot have a method on its own. It must be a part of a class.
	
//in file main.java
3 - public class anotherone{
}
class main {
   public static void main(String[] args) {
       System.out.println("hello");
   }
}
	//A public class must exist in a file by the same name. So this code is invalid because anotherone is a public class but 
	//the name of the file is main. It would have been valid if the name of the file were anotherone.java.
	//A non public class may exist in any file. This implies that there can be only one public class in a file.

//in file main.java
4 - class anothermain{ --CERTO
   public static void main(String[] args) {
       System.out.println("hello2");
   }
}
class main {
   public final static void main(String[] args) {
       System.out.println("hello");
   }
}
  //Observe that there is no public class in file main.java. This is ok. It is not necessary for a java file to have a 
// public class. The requirement is that if a class (or enum) is public then that class (or enum) must be defined in a file 
// by the same name and that there can be only one public class (or enum) in a file.

// class main's main method will be executed. final is a valid modifier for the standard main method.

// Note that final means a method cannot be overridden. Although static methods can never be overridden (they can be hidden), 
//making a static method final prevents the subclass from implementing the same static method.

General

Observe that the given code does not follow the standard Java naming convention. The class names should start with a capital letter.
There are questions in the exam that contain similar non-conventional and confusing names and that is why we have kept a few questions 
like that in this question bank

********************************************************************************************************************

30 - 

public class Triangle{
    public int base;
    public int height;
    public double area;
    
    public Triangle(int base, int height){
        this.base = base; this.height = height;
        updateArea();
    }

    void updateArea(){
        area = base*height/2;
    }
    public void setBase(int b){ base  = b; updateArea(); }
    public void setHeight(int h){ height  = h; updateArea(); }
}
The above class needs to protect an invariant on the "area" field. Which three members must have the public access modifiers removed 
to ensure that the invariant is maintained?

1 - the base field --CERTO
2 - the height field --CERTO
3 - the area field ----CERTO
4 - the Triangle constructor
5 - the setBase method
6 - the setHeight method


General

An invariant means a certain condition that constrains the state stored in the object. For example, in this case the value 
of the area field of the Triangle must always be consistent with its base and height fields. Thus, it should never have a 
value that is different from base*height/2.

If you allow other classes to directly change the value of base, height, or area, using direct field access, the area field 
may not contain the correct area thereby breaking the invariant.

To prevent this inconsistency from happening, you need to prohibit changing the instance fields directly and instead permit 
the changes only through the setter method because these methods call the updateArea method and keep the area and base and 
height consistent.

********************************************************************************************************************

31 - 

When a class whose members should be accessible only to members of that class is coded such a way that its members are 
accessible to other classes as well, this is called ...

1 - strong coupling
2 - weak coupling
3 - strong typing
4 - weak encapsulation --CERTO
5 - weak polymorphism
6 - high cohesion
7 - low cohesion

General
When a class is properly encapsulated, only the members that are part of its public API are publicly accessible to other 
classes. Rest is all private.

********************************************************************************************************************

32 - 

What will the following code snippet print when compiled and run?
byte starting = 3;
short firstValue = 5;
int secondValue = 7;
int functionValue = (int) (starting/2 + firstValue/2 + (int) firstValue/3 ) + secondValue/2;
System.out.println(functionValue);

1 - 7 --CERTO
2 - 8
3 - 10
4 - 11
5 - 12
6 - It will not compile.

General

  Remember that whenever both the operands of a mathematical operator (such as / and *) 
are integral types except long (i.e. byte, char, short, and int), the result is always 
the integer value that remains after truncating the fractional value. For example, 5/3 
is 1.6666 but the result will be 1 after removing the fractional part. Observe that 
there is no "rounding off" here.

In the expression given in this question, starting, firstValue, and secondValue are of 
type byte, short, and int respectively. Thus, the above rule is applicable here. 
Therefore, starting/2 will result in 1, firstValue/2 will result in 2, firstValue/3 
will result in 1, and secondValue/2 will result in 3. The expression will therefore be 
equivalent to:

      (int) ( 1 + 2 + 1 ) + 3
=> (int)(4) + 3
=> 7

Although not important for this question, you should remember that the type of the 
result will be int even if both the operands are of a type that is smaller than an int. 
Thus, the following will not compile -
byte b1 = 1;
byte b2 = 2;
byte b = b1 + b2; //result is of type int, which cannot be assigned directly to a byte

You have to use a cast:
byte b = (byte) (b1 + b2); //OK now

Similarly, when one of the operands is of type long, float, or double and the other operand
 is of a smaller size, the result will be a long, float, or double respectively.



33 - 

You are asked to develop an application for a car rental company. As a part of that, you are given the following requirements -
1. Implement three classes -  Car, SUV, and MiniVan, where the Car class is the super class of SUV as well as MiniVan.
2. Implement method int getDailyRate()  that returns the daily price of the car.
3. Implement method void printDetails() that prints the details of the car.

Which of the following definition of Car class adds a valid layer of abstraction to the class hierachy?

public abstract class Car{
   public abstract int getDailyRate();
   public void printDetails(){
    // code for printing details goes here
   }
}
Since Car class does not know the details of SUV and MiniVan, you can't provide the code for them in this class. Therefore, you should make this method abstract.
public abstract class Car{
   public int getDailyRate();
   public void printDetails();
}
This is invalid because of the lack of abstract keyword on the methods. This will not compile and is, therefore, an obviously wrong answer.
public abstract class Car{
   public abstract int getDailyRate();
   public abstract void printDetails();
}
As per the given information, Car could be an abstract class with two methods. You need to make these two methods abstract so that concrete classes such as SUV and MiniVan will be forced to provide appropriate implementations of these methods.
public abstract class Car{
   public abstract int getDailyRate();
   public abstract void printDetails(){
    // code for printing details goes here
   }
}
A method that has code cannot be abstract and vice-versa. This will not compile and is, therefore, an obviously wrong answer.

General

The problem statement is very ambiguous and there are multiple valid implementations. You will need to draw clues from the options and select the best option by eliminating options that are obviously wrong. Expect such questions in the exam.

********************************************************************************************************************

33 - 







